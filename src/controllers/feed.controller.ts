import { type NextFunction, type Request, type Response } from 'express';
import { Feed, type Author, type Item } from 'feed';
import Parser, { type Item as RssParserItem } from 'rss-parser';

import DirectusService from '@/services/directus.service';
import {
    type IDirectusDisplayableFeed,
    type IDirectusFeed,
    type IDirectusFeedFeed,
    type IDirectusFeedFilter,
    type IDirectusFeedGroup,
    type IDirectusFilter
} from '@/interfaces/directus.interface';
import FeedSender, { type FeedFormat } from '@/utils/feedSender';
import { HttpException } from '@/exceptions/HttpException';

class FeedController {
    private readonly service: DirectusService = new DirectusService();

    public getFeed = (req: Request, res: Response, next: NextFunction) => {
        const feedId = req.params.feed;

        this.service.getFeed(feedId).then((displayableFeed) => {
            const feedSender = new FeedSender(req, res);
            this.directusFeedToFeed(displayableFeed, req, feedSender.getFormat())
                .then(feed => { feedSender.send(feed); })
                .catch(next);
        }).catch(next);
    };

    private async directusFeedToFeed (displayableFeed: IDirectusDisplayableFeed, req: Request, format: FeedFormat): Promise<Feed> {
        const url = `${req.protocol}://${req.headers.host as string}${req.originalUrl}`;
        const feed = new Feed({
            id: url,
            title: displayableFeed.title,
            link: url,
            description: displayableFeed.description,
            copyright: ''
        });

        const directusFeed = displayableFeed.feed as IDirectusFeed;
        const items = await this.getFeedItems(directusFeed, format);
        items.forEach(feed.addItem);

        return feed;
    }

    private async getFeedItems (directusFeed: IDirectusFeed, format: FeedFormat): Promise<Item[]> {
        switch (directusFeed.type) {
            case 'feed': {
                const feed = directusFeed as IDirectusFeedFeed;
                return await this.loadItems(feed, format);
            }
            case 'group': {
                const feedGroup = directusFeed as IDirectusFeedGroup;
                const items = [];
                for (const child of feedGroup.groupChildren) {
                    const feed = child as IDirectusFeed;

                    items.push(...(await this.getFeedItems(feed, format)));
                }
                return items;
            }
            case 'filter': {
                const feedFilter = directusFeed as IDirectusFeedFilter;
                const feed = feedFilter.filterChild as IDirectusFeedFeed;
                const filter = feedFilter.filter;
                const originalItems = await this.getFeedItems(feed, format);

                return originalItems.filter(item => this.filterItem(item, filter));
            }
        }
    }

    private async loadItems (directusFeed: IDirectusFeedFeed, format: FeedFormat): Promise<Item[]> {
        const parser = new Parser();
        const feed = await parser.parseURL(directusFeed.feedUrl);
        return this.rssParserToFeedItems(feed, format);
    }

    /**
     * Convert a feed generated by the {@link Parser} to {@link Item}s
     *
     * @param originalFeed The feed generated by the {@link Parser}
     * @param format The format of the feed
     */
    private rssParserToFeedItems (originalFeed: Parser.Output<any>, format: FeedFormat): Item[] {
        return originalFeed.items.map((item: RssParserItem) => ({
            title: item.title ?? '',
            id: item.guid,
            link: item.link ?? '',
            date: item.isoDate !== undefined
                ? new Date(item.isoDate)
                : new Date(),
            description: item.content,
            content: item.content,
            category: item.categories !== undefined && item.categories.length > 0
                ? item.categories.map(category => ({ name: category }))
                : undefined,
            guid: item.guid,
            enclosure: item.enclosure,
            authors: this.formatAuthors(item.creator, format),
            published: item.pubDate !== undefined
                ? new Date(item.pubDate)
                : undefined
        }));
    }

    /**
     * Format an author string to an Author object
     *
     * Output format in normalised feed:
     * - In rss: `<author>email (name)</author>`
     * - In atom: `<name></name><email></email>`
     * - In json: `{author: {name: ""}}`
     *
     * @param creator The author string
     * @param format The format of the feed
     */
    private formatAuthors (creator: string | undefined, format: FeedFormat): Author[] | undefined {
        if (creator === undefined) return undefined;

        let authors: Author[] | undefined;
        if (format === 'json') {
            authors = [
                {
                    name: creator
                }
            ];
        } else {
            let name;
            let email;
            if (creator.includes('@')) {
                // on a un email
                if (creator.includes(' ')) {
                    // on a un nom
                    const split = creator.split(' ');
                    email = split.shift();
                    name = split.join(' ').trim();
                    if (name.startsWith('(') && name.endsWith(')')) {
                        name = name.slice(1, -1);
                    }
                } else {
                    // on n'a pas de nom mais on a un email
                    name = format === 'atom' ? undefined : creator;
                    email = creator;
                }
            } else {
                // on n'a pas d'email, mais on a un nom
                name = creator;
                email = format === 'atom' ? undefined : creator;
            }
            authors = [
                {
                    name,
                    email
                }
            ];
        }
        return authors;
    }

    private filterItem (item: Item, filter: IDirectusFilter): boolean {
        let itemValue = item[filter.field];
        if (itemValue === undefined) return !filter.keep;

        let values = filter.values ?? [];

        if (!filter.caseSensitive) {
            itemValue = itemValue.toLowerCase();
            values = values.map(value => value.toLowerCase());
        }

        switch (filter.type) {
            case 'equals': {
                return values.includes(itemValue) === filter.keep;
            }
            case 'contains': {
                switch (filter.behaviour) {
                    case 'oneOrMore': {
                        for (const value of values) {
                            if (itemValue.includes(value)) return filter.keep;
                        }
                        return !filter.keep;
                    }
                    case 'all': {
                        for (const value of values) {
                            if (!itemValue.includes(value)) return !filter.keep;
                        }
                        return filter.keep;
                    }
                    default: {
                        throw new HttpException(500, `Unknown filter behaviour ${String(filter.behaviour)}`);
                    }
                }
            }
            case 'regex': {
                if (filter.values === undefined || filter.values.length === 0) throw new HttpException(400, 'Regex filter must have at least one value');
                const regex = new RegExp(filter.values[0]);
                return regex.test(itemValue) === filter.keep;
            }
            default: {
                throw new HttpException(500, `Unknown filter type ${String(filter.type)}`);
            }
        }
    }
}

export default FeedController;
